GEMS: An Extract Method Refactoring Recommender,S. Xu; A. Sivaraman; S. -C. Khoo; J. Xu,2017 IEEE 28th International Symposium on Software Reliability Engineering (ISSRE),2017,"Extract Method is a widely used refactoring operation to improve method comprehension and maintenance. Much research has been done to extract codefragments within the method body to form a new method. Criteria used for identifying extractable code is usually centered around degrees of cohesiveness, coupling and length of the method. However, automatic method extraction techniques have not been highly successful, since it can be hard to concretizethe criteria. In this work, we present a novel system that learns these criteria for Extract Method refactorings from open source repositories. We extractstructural and functional features, which encode the concepts of complexity, cohesion and coupling in our learning model, and train it to extract suitablecode fragments from a given source of a method. Our tool, GEMS, recommends a ranked list of code fragments with high accuracy and greatspeed. We evaluated our approach on several open source repositories and compared it against three state-of-the-art approaches-SEMI, JExtract andJDeodorant. The results on these open-source data show the superiority of our machine-learning-based approach in terms of effectiveness. We develop GEMS asan Eclipse plugin, with the intention to support software reliability through method extraction.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8109070
A Methodology for Impact Evaluation of Refactoring on External Quality Attributes of a Software Design,R. S. Bashir; S. P. Lee; C. C. Yung; K. A. Alam; R. W. Ahmad,2017 International Conference on Frontiers of Information Technology (FIT),2017,"Refactoring aims at improving software design quality without affecting external behavior. It is commonly believed that refactoring operations always enhance the software quality. However, some recent empirical studies have reported negative or negligible effects of refactoring on certain quality attributes. The actual impact of each refactroing on certain quality attributes may help developers in selecting the most suitable refactoring alternatives. Various work have been proposed in this regard at source code-level. However, fewer studies have assessed the refactoring impact at design-level. In this study, We propose a refactoring impact evaluation method enabling developers to select the suitable refactoring operations based on their impact. Nine small scale case studies have been used to validate the consistency of propose method. The results reveal that move method, extract method, extract class rafactoring operations have improved maintainability, understandability, modifiability, and analyzability in nine case studies. These obeservations are consistent accross multiple case studies, implying that the proposed approach is highly consistent.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8261034
Identifying Fragments to be Extracted from Long Methods,L. Yang; H. Liu; Z. Niu,2009 16th Asia-Pacific Software Engineering Conference,2009,"Long and complex methods are hard to read or maintain, and thus usually treated as bad smells, known as Long Method. On the contrary, short and well-named methods are much easier to read, maintain, and extend. In order to divide long methods into short ones, refactoring Extract Method was proposed and has been widely used. However, extracting methods manually is time consuming and error prone. Though existing refactoring tools can automatically extract a selected fragment from its inclosing method, which fragment within a long method should be extracted has to be determined manually. In order to facilitate the decision-making, we propose an approach to recommend fragments within long methods for extraction. The approach is implemented as a prototype, called AutoMeD. With the tool, we evaluate the approach on a nontrivial open source project. The evaluation results suggest that refactoring cost of long methods can be reduced by nearly 40%. The main contribution of this paper is an approach to recommending fragments within long methods to be extracted, as well as an initial evaluation of the approach.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5358495
Removing Code Clones from Industrial Systems Using Compiler Directives,T. Hatano; A. Matsuo,2017 IEEE/ACM 25th International Conference on Program Comprehension (ICPC),2017,"Refactoring of code clones is an effective method for improving software maintainability. Existing studies have proposed automated techniques and tools for refactoring. However, it is difficult to apply refactoring to our industrial systems in practice because of three main reasons. First, we have many industrial systems written in COBOL which requires a particular refactoring method compared with current techniques because Type-2 clones in COBOL are generated by renaming parts of identifiers. Second, nested clones must be refactored, in which an instance of a clone set is contained within an instance of another clone set. They also make it difficult to estimate the reduction size by refactoring. Third, refactoring requires testing which is time-consuming and laborious. To overcome these problems, we developed an approach for refactoring of Type-2 clones in COBOL programs. Our approach identifies actual refactorable clone sets and includes a string comparison technique to parameterize partial differences in identifier names. The clone sets are extracted as shared code fragments and transformed into the refactored code using compiler directives. It is easy to confirm that refactoring using compiler directives preserves program behavior, because they do not change program structure. We also provide a method that makes it possible to refactor nested clones by ordering their refactoring. This method enables to estimate how many lines can be reduced by refactoring. We applied the approach to four industrial systems to assess how many lines can be reduced. The results show that the lines could be reduced by 10 to 15% and one system was reduced by 27%. We also discuss the parameter number required for our refactoring approach.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7961534
Fourth workshop on refactoring tools: (WRT 2011),D. Dig; D. Batory,2011 33rd International Conference on Software Engineering (ICSE),2011,"Refactoring is the process of applying behavior-preserving transformations to a program with the objective of improving the program's design. A specific refactoring is identified by a name (e.g., Extract Method), a set of preconditions, and a set of transformations that need to be performed. Tool support for refactoring is essential because checking the preconditions of refactoring often requires nontrivial program analysis, and applying transformations may affect many locations throughout a program. In recent years, the emergence of light-weight programming methodologies such as Extreme Programming has generated a great amount of interest in refactoring, and refactoring support has become a required feature in today's IDEs. This workshop is a continuation of a series of previous workshops (ECOOP 2007, OOPSLA 2008 and 2009 - see http://refactoring.info/WRT) where researchers and developers of refactoring tools can meet and discuss recent ideas and work, and view tool demonstrations.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6032636
Using software metrics to select refactoring for long method bad smell,P. Meananeatra; S. Rongviriyapanish; T. Apiwattanapong,"The 8th Electrical Engineering/ Electronics, Computer, Telecommunications and Information Technology (ECTI) Association of Thailand - Conference 2011",2011,"Refactoring is a technique for improving software structure without changing its behavior which can be used to remove bad smells and increases software maintainability. But only few approaches have been proposed to address the identification of appropriate refactorings. Specifically, our research proposes a method to select refactoring based on software metrics which are defined in terms of data flow and control flow graphs. The method consist of 4 steps: 1) calculate metrics, 2) find candidate refactoring by using refactoring filtering condition (RFC), 3) apply a suite of candidate refactorings and compute maintainability, and 4) identify the refactoring that gives the highest maintainability. We demonstrate out approach by giving an example of removing a long method bad smell in a customer class in a movie rental system. Our approach proves to be able to suggest an appropriate set of refactoring techniques such as extract method, replace temp with query, and decompose condition, to solve the long method bad smell.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5947882
Identification of Extract Method Refactoring Opportunities,N. Tsantalis; A. Chatzigeorgiou,2009 13th European Conference on Software Maintenance and Reengineering,2009,"Extract method has been recognized as one of the most important refactorings, since it decomposes large methods and can be used in combination with other refactorings for fixing a variety of design problems. However, existing tools and methodologies support extraction of methods based on a set of statements selected by the user in the original method. The goal of the proposed methodology is to automatically identify extract method refactoring opportunities and present them as suggestions to the designer of an object-oriented system. The suggested refactorings adhere to three principles: the extracted code should contain the complete computation of a given variable declared in the original method, the behavior of the program should be preserved after the application of the refactoring, and the extracted code should not be excessively duplicated in the original method. The proposed approach is based on the union of static slices that result from the application of a block-based slicing technique. The soundness of the identified refactoring opportunities has been evaluated by an independent designer on the system that he developed.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4812745
TOAD: A Tool for Recommending Auto-Refactoring Alternatives,A. Siles Antezana,2019 IEEE/ACM 41st International Conference on Software Engineering: Companion Proceedings (ICSE-Companion),2019,"Developers often face usability problems when trying to adopt refactoring tools. We replicate a user study to identify and categorize these problems, and we propose a tool that guides the developer to select the correct piece of code for Extract Method refactoring. Our tool works during the workflow of refactoring activities and selects candidate selections that (i) are syntactically correct and (ii) meet the necessary preconditions for Extract Method.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8802787
RMove: Recommending Move Method Refactoring Opportunities using Structural and Semantic Representations of Code,D. Cui; S. Wang; Y. Luo; X. Li; J. Dai; L. Wang; Q. Li,2022 IEEE International Conference on Software Maintenance and Evolution (ICSME),2022,"Incorrect placement of methods within classes is a typical code smell called Feature Envy, which causes additional maintenance and cost during evolution. To remove this design flaw, several Move Method refactoring tools have been proposed. To the best of our knowledge, state-of-the-art related techniques can be broadly divided into two categories: the first line is non-machine-learning-based approaches built on software measurement, while the selection and thresholds of software metrics heavily rely on expert knowledge. The second line is machine learning-based approaches, which suggest Move Method refactoring by learning to extract features from code information. However, most approaches in this line treat different forms of code information identically, disregarding their significant variation on data analysis. In this paper, we propose an approach to recommend Move Method refactoring named RMove by automatically learning structural and semantic representation from code fragment respectively. We concatenate these representations together and further train the machine learning classifiers to guide the movement of method to suitable classes. We evaluate our approach on two publicly available datasets. The results show that our approach outperforms three state-of-the-art refactoring tools including PathMove, JDeodorant, and JMove in effectiveness and usefulness. The results also unveil useful findings and provide new insights that benefit other types of feature envy refactoring techniques.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9978256
On the Alternatives for Composing Batch Refactoring,E. Fernandes; A. UchÃ´a; A. C. Bibiano; A. Garcia,2019 IEEE/ACM 3rd International Workshop on Refactoring (IWoR),2019,"Code refactoring is often performed for improving code structures through code transformations. Many transformations, e.g., extracting or moving a method, are applied for at least partially removing code smells. Each code smell is a symptom of a poor code structure that makes hard to read and change the program. Developers often compose two or more interrelated transformations in conjunction (batch refactoring) rather than applying a single transformation. For instance, developers often compose method extractions with method motions to better organize the features realized by classes. We have recently observed cases of batch refactoring performed along with code review in open source projects. We then noticed that composing batches capable of fully removing code smells is quite challenging. Especially, it requires carefully discussing on how two or more transformations complement one another and what to expect from the batch effect on code smell. This position aims to reason about multiple alternatives to support developers on composing their batches. These alternatives should make it easier to compose batches that remove code smells. For this purpose, we exemplify the role of semi-automated tools in gradually recommending transformations, thereby guiding the batch composition in each alternative.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8844411
Assisting Replace Method with Method Object: Selecting Fields and Preserving Data Access,A. Fornaia; E. Tramontana,2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC),2018,"The work of decomposing long methods into smaller ones is commonly assisted by the Extract Method refactoring technique. However, local variable usages can make code extraction difficult. Therefore, Replace Method with Method Object refactoring technique lets the developer create a field for each variable, and then code extractions can be performed without worrying about variable dependences. However, this can lead to classes having many fields used by a few of its methods. Moreover, the considered fields may not correctly describe the actual object state, making the class harder to understand. This paper proposes a data dependence analysis approach for guiding the Replace Method with Method Object refactoring technique, with the aim of reducing the set of variables becoming fields while properly handling data dependence. The resulting class is easier to understand, having less fields holding the state, while using local variables and parameters to confine all the other data dependence details.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377921
Automatic code locations identification for replacing temporary variable with query method,S. Rongviriyapanish; N. Karunlanchakorn; P. Meananeatra,"2015 12th International Conference on Electrical Engineering/Electronics, Computer, Telecommunications and Information Technology (ECTI-CON)",2015,"Automatic application of refactoring techniques can help developer save effort for removing bad smells from their code which improves software maintainability. To remove automatically long method bad smell, which is one of the most serious bad smells, we need an automatic application of six refactoring techniques. However, only one refactoring technique â€œExtract Methodâ€ can be automated. In this research, we propose an algorithm to identify code locations which will be extracted for creating a query method. We performed an experiment to conclude the workability and correctness of our algorithm. This is the most important step towards an automatic application of refactoring technique â€œreplace temp with queryâ€.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7207086
Refactoring Generics in JAVA: A Case Study on Extract Method,R. Marticorena; C. LÃ³pez; Y. Crespo; F. J. PÃ©rez,2010 14th European Conference on Software Maintenance and Reengineering,2010,"The addition of support for genericity to mainstream programming languages has a notable influence in refactoring tools. This also applies to the JAVA programming language. Those versions of the language specification prior to JAVA 5 did not include support for generics. Therefore, refactoring tools had to evolve to modify their refactoring implementations according to the new language characteristics in order to assure the correct effects when transforming code containing generic definitions or using generic instantiations. This paper presents an evaluation of the behaviour of refactoring tools on source code that defines or uses generics. We compare the behaviour of five refactoring tools on a well known refactoring, Extract Method, and its implementation for the JAVA language. We distill the lessons learned from our evaluation into requirements that have to be taken into account by refactoring tools in order to fully conform to this new language feature.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5714438
A Tool Supporting Postponable Refactoring,K. Maruyama; S. Hayashi,2017 IEEE/ACM 39th International Conference on Software Engineering Companion (ICSE-C),2017,"Failures of precondition checking when attempting to apply automated refactorings often discourage programmers from attempting to use these refactorings in the future. To alleviate this situation, the postponement of the failed refactoring instead its cancellation is beneficial. This poster paper proposes a new concept of postponable refactoring and a prototype tool that implements postponable Extract Method as an Eclipse plug-in. We believe that this refactoring tool inspires a new field of reconciliation automated and manual refactoring.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965279
Parameter-Based Refactoring and the Relationship with Fan-in/Fan-out Coupling,A. Murgia; M. Marchesi; G. Concas; R. Tonelli; S. Counsell,"2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops",2011,"Refactoring is an activity which, in theory, should have minimal impact on the overall structure of a system. That said, certain refactorings change the coupling profile of a system and over time those cumulative changes in coupling can have serious implications for system maintenance effort. In this paper, we analyse effect of the fan-in and fan-out metrics from the perspective of two refactorings - namely 'Add parameter' to, and 'Remove Parameter' from, a method. We developed a bespoke pattern-matching tool to collect these two refactorings from multiple releases of the Tomcat open-source system using the Evolizer tool to extract method signature data and the JHawk metrics tool to collect the two coupling metrics. Results point to significant differences in the profiles of fan-in and fan-out between refactored and non-refactored classes. We describe how software company can take advantage from this knowledge by defining a priority list of classes which could require a refactoring. A strong over-arching theme emerged: developers seemed to focus on the refactoring of classes with relatively high fan-in and fan-out rather than classes with high values in any one. The study is the first that we know of to analyse the direct effect of a subset of Fowler's refactorings on fan-in and fan-out - relevant metrics of the overall structure of a system.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5954443
Identifying Extract Method Refactoring Opportunities Based on Functional Relevance,S. Charalampidou; A. Ampatzoglou; A. Chatzigeorgiou; A. Gkortzis; P. Avgeriou,IEEE Transactions on Software Engineering,2017,"`Extract Method' is considered one of the most frequently applied and beneficial refactorings, since the corresponding Long Method smell is among the most common and persistent ones. Although Long Method is conceptually related to the implementation of diverse functionalities within a method, until now, this relationship has not been utilized while identifying refactoring opportunities. In this paper we introduce an approach (accompanied by a tool) that aims at identifying source code chunks that collaborate to provide a specific functionality, and propose their extraction as separate methods. The accuracy of the proposed approach has been empirically validated both in an industrial and an open-source setting. In the former case, the approach was capable of identifying functionally related statements within two industrial long methods (approx. 500 LoC each), with a recall rate of 93 percent. In the latter case, based on a comparative study on open-source data, our approach ranks better compared to two well-known techniques of the literature. To assist software engineers in the prioritization of the suggested refactoring opportunities the approach ranks them based on an estimate of their fitness for extraction. The provided ranking has been validated in both settings and proved to be strongly correlated with experts' opinion.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7801138
Are Refactorings to Blame? An Empirical Study of Refactorings in Merge Conflicts,M. Mahmoudi; S. Nadi; N. Tsantalis,"2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)",2019,"With the rise of distributed software development, branching has become a popular approach that facilitates collaboration between software developers. One of the biggest challenges that developers face when using multiple development branches is dealing with merge conflicts. Conflicts occur when inconsistent changes happen to the code. Resolving these conflicts can be a cumbersome task as it requires prior knowledge about the changes in each of the development branches. A type of change that could potentially lead to complex conflicts is code refactoring. Previous studies have proposed techniques for facilitating conflict resolution in the presence of refactorings. However, the magnitude of the impact that refactorings have on merge conflicts has never been empirically evaluated. In this paper, we perform an empirical study on almost 3,000 well-engineered open-source Java software repositories and investigate the relation between merge conflicts and 15 popular refactoring types. Our results show that refactoring operations are involved in 22% of merge conflicts, which is remarkable taking into account that we investigated a relatively small subset of all possible refactoring types. Furthermore, certain refactoring types, such as EXTRACT METHOD, tend to be more problematic for merge conflicts. Our results also suggest that conflicts that involve refactored code are usually more complex, compared to conflicts with no refactoring changes.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668012
Safe clone-based refactoring through stereotype identification and iso-generation,N. Volanschi,2012 6th International Workshop on Software Clones (IWSC),2012,"Most advanced existing tools for clone-based refactoring propose a limited number of predefined clone-removal transformations that can be applied automatically, typically under user control. This fixed set of refactorings usually guarantee that semantics is preserved, but is inherently limited to generally-applicable transformations (extract method, pull-up method, etc.). This tool design rules out many potential domain-specific or application-specific clone removals. Such cases are ordinarily recognized by humans as stereotypes derived from a higher-level concept and manually replaced with an appropriate abstraction. Thus, in current tools, generality is sacrificed for the safety of the transformation. This paper proposes an alternative approach, in which the spectrum of refactoring techniques is open, including manual interventions, while keeping strong safety guarantees based on the notion of iso-generation. Our method can operate on multiple languages and has been prototyped on a subset of a real-world legacy asset containing C and COBOL programs, with promising results.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6227866
How Developers Discuss Architecture Smells? An Exploratory Study on Stack Overflow,F. Tian; P. Liang; M. A. Babar,2019 IEEE International Conference on Software Architecture (ICSA),2019,"Architecture Smells (ASs) are design decisions that can have significant negative effects on a system's quality attributes such as reusability and testability. ASs are focused on higher level of software systems than code smells, which are implementation-level constructs. ASs can have much wider impact on a system than code smells. However, ASs usually receive less attention than code smells in both research and practice. We have conducted an exploratory study of developers' conception of ASs by analyzing related discussions in Stack Overflow. We used 14 ASs related terms to search the relevant posts in Stack Overflow and extracted 207 posts. We used Grounded Theory method for analyzing the extracted posts about developers' description of ASs, causes of ASs, approaches and tools for detecting and refactoring ASs, quality attributes affected by ASs, and difficulties in detecting and refactoring ASs. Our findings show that: (1) developers often describe ASs with some general terms; (2) ASs are mainly caused by violating architecture patterns, design principles, or misusing architecture antipatterns; (3) there is a lack of dedicated tools for detecting and refactoring ASs; (4) developers mainly concern about the maintainability and performance of systems affected by ASs; and (5) the inability to quantify the cost and benefit as well as the lack of approaches and tools makes detecting and refactoring ASs difficult.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8703915
Measuring Class Cohesion Based on Client Similarities Between Method Pairs: An Improved Approach That Supports Refactoring,M. Alzahrani,IEEE Access,2020,"Class cohesion is an important quality attribute that has an impact on other quality attributes such understandability, testability, and maintainability. Therefore, classes with low cohesion should be refactored in order to improve their overall qualities. Many cohesion metrics have been introduced in the literature to automatically assess the quality of the class and support refactoring activities. Most existing metrics measure the class cohesion based on how the methods of a class are internally related to each other, while a few metrics measure the class cohesion based on how the methods are externally used by the clients of the class. Unfortunately, the existing client-based cohesion metrics cannot automatically support refactoring techniques such as the Extract Class refactoring. Therefore, this article proposes a new client-based cohesion metric that can be used to automatically identify Extract Class refactoring opportunities. The proposed metric is theoretically evaluated by proving the compliance of the metric to the mathematical cohesion properties, while it is empirically evaluated by conducting a large case study on three systems to compare the metric with other cohesion metrics. Finally, the paper introduces and evaluates an Extract Class refactoring approach based the proposed cohesion metric.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9300041
Does Automated Refactoring Obviate Systematic Editing?,Na Meng; L. Hua; Miryung Kim; K. S. McKinley,2015 IEEE/ACM 37th IEEE International Conference on Software Engineering,2015,"When developers add features and fix bugs, they often make systematic edits-similar edits to multiple locations. Systematic edits may indicate that developers should instead refactor to eliminate redundancy. This paper explores this question by designing and implementing a fully automated refactoring tool called RASE, which performs clone removal. RASE (1) extracts common code guided by a systematic edit; (2) creates new types and methods as needed; (3) parameterizes differences in types, methods, variables, and expressions; and (4) inserts return objects and exit labels based on control and data flow. To our knowledge, this functionality makes RASE the most advanced refactoring tool for automated clone removal. We evaluate RASE with real-world systematic edits and compare to method based clone removal. RASE successfully performs clone removal in 30 of 56 method pairs (n=2) and 20 of 30 method groups (nâ‰¥3) with systematic edits. We find that scoping refactoring based on systematic edits (58%), rather than the entire method (33%), increases the applicability of automated clone removal. Automated refactoring is not feasible in the other 42% cases, which indicates that automated refactoring does not obviate the need for systematic editing.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7194591
Comparing Execution Traces of Jupyter Notebook for Checking Correctness of Refactoring,F. Sato; A. Ikegami; T. Ishio; K. Shimari; K. Matsumoto,2022 IEEE 16th International Workshop on Software Clones (IWSC),2022,"Jupyter Notebook is a popular tool for writing data analysis programs. Prior work showed that Jupyter Notebook users often duplicate their python code to try their hypothesis quickly. While such code clones can be removed by Extract Function refactoring later, users have to check that the output of a notebook is unaffected by the refactoring. However, users may not be able to compare execution results of a notebook before and after refactoring because non-textual output in Jupyter Notebook are fragile; for example, each of executions produce non-identical graphical images even though they look the same. To address this issue, we propose a method to automatically compare API calls to execute a Jupyter Notebook in addition to the textual output, while ignoring non-textual output. Our key assumption is that the same API calls with the same parameters produce the same results even if their details are non-identical. To demonstrate the effectiveness of the approach, we implemented an automatic tool for Jupyter Notebook that extracts a function from code clones and automatically checks the correctness. Using the tool, we have extracted functions from 3,995 cells in 520 Jupyter Notebook files. 142 out of 520 Notebook files are executable. Our tool compared API calls to check the correctness for 88 Notebook files, while a simple textual comparison could check 22 Notebook files.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9978248
An Automatic Advisor for Refactoring Software Clones Based on Machine Learning,A. M. Sheneamer,IEEE Access,2020,"To assist developers refactored code and to enable improvements to software quality when numbers of clones are found in software programs, we require an approach to advise developers on what a clone needs to refactor and what type of refactoring is needed. This paper suggests a unique learning method that automatically extracts features from the detected code clones and trains models to advise developers on what type needs to be refactored. Our approach differs from others, which specifies types of refactored clones as classes and creates a model for detecting the types of refactored clones and the clones which are anonymous. We introduce a new method by which to convert refactoring clone type outliers into Unknown clone set to improve classification results. We present an extensive comparative study and an evaluation of the efficacy of our suggested idea by using state-of-the-art classification models.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9130671
Improving the quality of software by refactoring,G. Kaur; B. Singh,2017 International Conference on Intelligent Computing and Control Systems (ICICCS),2017,"Software code management has become another key skill required by software architects and software developers. Size of software increases with increase in count of features in software. Code refactoring is process of reducing code maintenance cost. It is achieved by many different techniques like extract, move methods, fields or classes in code. In this research we focused on improving the maintainability of the code by looking into the different refactoring techniques and improving upon them. We proposed an algorithm to improve the refactoring process which results in higher maintainability. To look into the validity of our proposed algorithm, we have used Junit and reffinder to analyse the code and generate the result metrics. We have observed the effectiveness of our work by comparing the different code maintainability indexes generated by the tool. In our research we have examined four releases of the software project for code refactoring and maintainability. Adding some extra features and using enhanced refactoring techniques measuring the code metrics and comparing the results of current releases with the previous releases.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8250707
[Journal First] The Scent of a Smell: An Extensive Comparison Between Textual and Structural Smells,F. Palomba; A. Panichella; A. Zaidman; R. Oliveto; A. De Lucia,2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE),2018,"Code smells are symptoms of poor design or implementation choices that have a negative effect on several aspects of software maintenance and evolution, such as program comprehension or change-and fault-proneness. This is why researchers have spent a lot of effort on devising methods that help developers to automatically detect them in source code. Almost all the techniques presented in literature are based on the analysis of structural properties extracted from source code, although alternative sources of information (e.g., textual analysis) for code smell detection have also been recently investigated. Nevertheless, some studies have indicated that code smells detected by existing tools based on the analysis of structural properties are generally ignored (and thus not refactored) by the developers. In this paper, we aim at understanding whether code smells detected using textual analysis are perceived and refactored by developers in the same or different way than code smells detected through structural analysis. To this aim, we set up two different experiments. We have first carried out a software repository mining study to analyze how developers act on textually or structurally detected code smells. Subsequently, we have conducted a user study with industrial developers and quality experts in order to qualitatively analyze how they perceive code smells identified using the two different sources of information. Results indicate that textually detected code smells are easier to identify and for this reason they are considered easier to refactor with respect to code smells detected using structural properties. On the other hand, the latter are often perceived as more severe, but more difficult to exactly identify and remove.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453146
Automatic Software Refactoring via Weighted Clustering in Method-Level Networks,Y. Wang; H. Yu; Z. Zhu; W. Zhang; Y. Zhao,IEEE Transactions on Software Engineering,2018,"In this study, we describe a system-level multiple refactoring algorithm, which can identify the move method, move field, and extract class refactoring opportunities automatically according to the principle of â€œhigh cohesion and low coupling.â€ The algorithm works by merging and splitting related classes to obtain the optimal functionality distribution from the system-level. Furthermore, we present a weighted clustering algorithm for regrouping the entities in a system based on merged method-level networks. Using a series of preprocessing steps and preconditions, the â€œbad smellsâ€ introduced by cohesion and coupling problems can be removed from both the non-inheritance and inheritance hierarchies without changing the code behaviors. We rank the refactoring suggestions based on the anticipated benefits that they bring to the system. Based on comparisons with related research and assessing the refactoring results using quality metrics and empirical evaluation, we show that the proposed approach performs well in different systems and is beneficial from the perspective of the original developers. Finally, an open source tool is implemented to support the proposed approach.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7874207
A Search-Based Approach on Metaheuristic Algorithm for Software Modularization to optimize Software Modularity,D. Sharma; S. Lohchab,2022 6th International Conference on Computing Methodologies and Communication (ICCMC),2022,"Software refactoring is a process to maintain software quality that will further improvise the software's internal structure without amending its external behaviour. The software refactoring is implemented in the software maintenance phase by modularizing the source code of the original Software clustering is a modularization approach that is used to modularize source code objects with the purpose of boosting the code's reusability and readability. Owing to the clustering issue being NP-hard, evolutionary methods like the genetic algorithm were utilized to address it. There is no search-based technique for modularization that uses a hierarchical method in the structural refactoring literature. It is an unsubstantiated learning technique utilized to cluster software objects (for example files, classes, or modules) with similar structures. The attained clusters can be utilized for a research study, analysis, and comprehending the software objectsâ€™ structure and behaviour. While one observation is that executing software module clustering with optimum consequences is thought-provoking. In the research paper, we have utilized the local and global methods wherein a metaheuristic hierarchal search-based clustering approach has been introduced that can help in modularizing the software system. In the algorithm, the outcome is a tree that has nodes including artifacts wherein sub trees collate these artifacts and it is a cluster that is a candidate solution. This algorithm will help in extracting a newer model of the source code which will further help in deciding the correct artifacts which will redirect to obtain documents, packages, and components. The source code can be fetched from GitHub.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9753800
Automatizing Software Cognitive Complexity Reduction,R. Saborido; J. Ferrer; F. Chicano; E. Alba,IEEE Access,2022,"Software plays a central role in our life nowadays. We use it almost anywhere, at any time, and for everything: to browse the Internet, to check our emails, and even to access critical services such as health monitoring and banking. Hence, its reliability and general quality is critical. As software increases in complexity, developers spend more time fixing bugs or making code work rather than designing or writing new code. Thus, improving software understandability and maintainability would translate into an economic relief over the total cost of a project. Different cognitive complexity measures have been proposed to quantify the understandability of a piece of code and, therefore, its maintainability. However, the cognitive complexity metric provided by SonarSource and integrated in SonarCloud and SonarQube is quickly spreading in the software industry due to the popularity of these well-known static code tools for evaluating software quality. Despite SonarQube suggests to keep methodâ€™s cognitive complexity no greater than 15, reducing methodâ€™s complexity is challenging for a human programmer and there are no approaches to assist developers on this task. We model the cognitive complexity reduction of a method as an optimization problem where the search space contains all sequences of Extract Method refactoring opportunities. We then propose a novel approach that searches for feasible code extractions allowing developers to apply them, all in an automated way. This will allow software developers to make informed decisions while reducing the complexity of their code. We evaluated our approach over 10 open-source software projects and was able to fix 78% of the 1,050 existing cognitive complexity issues reported by SonarQube. We finally discuss the limitations of the proposed approach and provide interesting findings and guidelines for developers.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9686676
Refactoring Real-Time Java Profiles,H. SÃ¸ndergaard; B. Thomsen; A. P. Ravn; R. R. Hansen; T. BÃ¸gholm,2011 14th IEEE International Symposium on Object/Component/Service-Oriented Real-Time Distributed Computing,2011,"Just like other software, Java profiles benefits from refactoring when they have been used and have evolved for some time. This paper presents a refactoring of the Real-Time Specification for Java (RTSJ) and the Safety Critical Java (SCJ) profile (JSR-302). It highlights core concepts and makes it a suitable foundation for the proposed levels of SCJ. The ongoing work of specifying the SCJ profile builds on sub classing of RTSJ. This spurred our interest in a refactoring approach. It starts by extracting the common kernel of the specifications in a core package, which defines interfaces only. It is then possible to refactor SCJ with its three levels and RTSJ in such a way that each profile is in a separate package. This refactoring results in cleaner class hierarchies with no superfluous methods, well defined SCJ levels, elimination of SCJ annotations like @SCJAllowed, thus making the profiles easier to comprehend and use for application developers and students.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5753598
Object-Oriented Code Metric-Based Refactoring Opportunities Identification Approaches: Analysis,I. Bassey; N. Dladlu; B. Ele,"2016 4th Intl Conf on Applied Computing and Information Technology/3rd Intl Conf on Computational Science/Intelligence and Applied Informatics/1st Intl Conf on Big Data, Cloud Computing, Data Science & Engineering (ACIT-CSII-BCD)",2016,"This paper presents analysis of existing empirical studies of software metric-based refactorings opportunities identification (ROI) for object-oriented (OO) software systems. We carried out a comprehensive analysis on sixteen (16) primary studies to identify the state-of-the-practice in ROI, focusing on their operations, refactoring activities, programming languages and the impact on software quality. The analysis results show that ROI approaches were designed for either a single refactoring activity or couple of them. Additionally, move method and extract class refactoring were the most refactorings activities performed on OO software systems. Also, OO metrics played an indispensable role in both opportunity detection and refactoring decisions. With the obtained results, we recommend the development of a generic ROI approach that is capable of identifying opportunities for all refactoring activities as well as suggesting the appropriate refactoring operations to apply.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7916960
Using structural and semantic metrics to improve class cohesion,A. De Lucia; R. Oliveto; L. Vorraro,2008 IEEE International Conference on Software Maintenance,2008,"Several refactoring methods have been proposed in the literature to improve the cohesion of classes. Very often, refactoring operations are guided by cohesion metrics based on the structural information of the source code, such as attribute references in methods. In this paper we present a novel approach to guide the extract class refactoring (M. Fowler, 1999), taking into account structural and semantic cohesion metrics. The proposed approach has been evaluated in a case study conducted on JHotDraw, an open source software system. The achieved results revealed that the performance achieved with the proposed approach significantly outperforms the results achieved with methods considering only structural or semantic information. The proposed approach has also been integrated in the Eclipse platform.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4658051
Look Ahead! Revealing Complete Composite Refactorings and their Smelliness Effects,A. C. Bibiano; W. K. G. AssunÃ§Ã£o; D. Coutinho; K. Santos; V. Soares; R. Gheyi; A. Garcia; B. Fonseca; M. Ribeiro; D. Oliveira; C. Barbosa; J. L. Marques; A. Oliveira,2021 IEEE International Conference on Software Maintenance and Evolution (ICSME),2021,"Recent studies have revealed that developers often apply composite refactorings (or, simply, composites). A composite consists of two or more interrelated refactorings applied together. Previous studies investigated the effect of composites on code smells. A composite is considered â€œcompleteâ€ whenever it completely removes one target code smell. They proposed descriptions of complete composites with recommendations to remove certain code smell types, such as Long Methods and Feature Envies. These studies also present different recommendations to remove the same code smell type. However, these studies: (i) are limited to composites only consisting of a small subset of Fowler's refactoring types, (ii) do not detail the scenarios in which each recommendation can be applied to remove the code smell, and (iii) fail in reporting possible side effects of the described composites, such as adversely introducing certain smell types. This paper aims to cover these limitations by performing a systematic analysis of 618 complete composites on removing four common smell types identified in 20 software projects. Our results indicated that: (i) 64% complete composites consisted of refactoring types not covered by existing descriptions of complete composites, and (ii) 36% complete composites formed by Extract Methods can introduce Feature Envies and Intensive Couplings. This information is not documented by existing descriptions, and it can alert developers about alternatives to remove Feature Envy, mainly in methods that are fully envious. These results suggest existing descriptions of complete composites should be either revisited or enhanced to explicitly highlight known side effects. We present a catalog of composites with details about side effects, recommendations to remove or minimize them, and some scenarios in which each recommendation can be applied to remove the code smell. Our catalog can be useful to improve existing tooling support for refactorings, such as IDEs, informing about possible side effects when refactorings are composed.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9609218
Using Software Metrics to detect Temporary Field code smell,R. Gupta; S. K. Singh,"2020 10th International Conference on Cloud Computing, Data Science & Engineering (Confluence)",2020,"Code smell is a characteristic of the source code which indicates some serious problem in the code which might affect the quality of the source code. There exists a list of 22 code smells as defined by Martin Fowler. But all these code smells have not been worked upon. Temporary field code smell is one of them, which has not been considered for its detection and refactoring. In this paper, we have reconstructed a motivating example of object oriented JAVA code that indicates the impact of code smell and need to remove temporary field based on metrics and rules.We have proposed a method to detect temporary field code smell based on software metrics derived from data flow and control flow graphs. We also proposed the process of refactoring the code to improve the maintainability. Analysis of results has shown that NFM, NMN, NCF metrics can help to detect Temporary field code smell. Extract class is more appropriate refactoring technique than parameter passing to remove Temporary Field code smell.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9058138
Identification of Move Method Refactoring Opportunities,N. Tsantalis; A. Chatzigeorgiou,IEEE Transactions on Software Engineering,2009,"Placement of attributes/methods within classes in an object-oriented system is usually guided by conceptual criteria and aided by appropriate metrics. Moving state and behavior between classes can help reduce coupling and increase cohesion, but it is nontrivial to identify where such refactorings should be applied. In this paper, we propose a methodology for the identification of Move Method refactoring opportunities that constitute a way for solving many common feature envy bad smells. An algorithm that employs the notion of distance between system entities (attributes/methods) and classes extracts a list of behavior-preserving refactorings based on the examination of a set of preconditions. In practice, a software system may exhibit such problems in many different places. Therefore, our approach measures the effect of all refactoring suggestions based on a novel entity placement metric that quantifies how well entities have been placed in system classes. The proposed methodology can be regarded as a semi-automatic approach since the designer will eventually decide whether a suggested refactoring should be applied or not based on conceptual or other design quality criteria. The evaluation of the proposed approach has been performed considering qualitative, metric, conceptual, and efficiency aspects of the suggested refactorings in a number of open-source projects.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4752842
Research on Detecting and Validating Design Pattern Instances from Source Code,W. Li; G. Chen; J. Pan,2012 International Conference on Computer Science and Service System,2012,"Identifying design patterns from source code is one of the most promising methods for improving software maintainability, reusing experience and facilitating software refactoring. In this paper, an approach that combines static and dynamic analysis on detecting design patterns from java source code is presented. Static structure analysis of identifying pattern instances is illustrated. Especially, to improve the detecting precision, multiplicity analysis of object creation is executed to validate creational pattern candidates and dynamic analysis which is the process of monitoring sequence of method calls in pattern candidates and judging if it is consistent to the expected pattern behavior is executed to validate behavior pattern candidates. After the validation of behavior candidates, those instances belong to patterns which have similar structure but different behavior are distinguished successfully. Finally, a tool of extracting design pattern from java source code is implemented and the feasibility of this approach is verified through the results of applying it on an open source software.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6394614
Generating Refactoring Proposals to Remove Clones from Automated System Tests,B. Hauptmann; S. Eder; M. Junker; E. Juergens; V. Woinke,2015 IEEE 23rd International Conference on Program Comprehension,2015,"Automated system tests often have many clones, which make them complex to understand and costly to maintain. Unfortunately, removing clones is challenging as there are numerous possibilities of how to refactor them to reuse components such as subroutines. Additionally, clones often overlap partly which makes it particularly difficult to decide which parts to extract. If done wrongly, reuse potential is not leveraged optimally and structures between tests and reuse components will become unnecessarily complex. We present a method to support test engineers in extracting overlapping clones. Using grammar inference algorithms, we generate a refactoring proposal that demonstrates test engineers how overlapping clones can be extracted. Furthermore, we visualize the generated refactoring proposal to make it easily understandable for test engineers. An industrial case study demonstrates that our approach helps test engineers to gain information of the reuse potential of test suites and guides them to perform refactorings.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181438
A New Clone Group Mapping Algorithm for Extracting Clone Genealogy on Multi-version Software,M. Ci; X. -h. Su; T. -t. Wang; P. -j. Ma,"2013 Third International Conference on Instrumentation, Measurement, Computer, Communication and Control",2013,"Research on code clone evolution is very hot, and it can contribute to the investigation of the characteristics, the maintenance, the refactoring, and the harmfulness evaluation of code clones. In clone evolution research, extracting clone genealogies is the key technique, and mapping clone groups between neighboring software versions is a thorny issue for extracting clone genealogies. The efficiency and robustness of the current method are not satisfactory. To address this problem, this paper presents a new clone group mapping algorithm in order to extract the clone genealogy. The algorithm takes NICAD's results as input, and describes the information of code clones with CRD, and maps the clone groups as well as the clone fragments according to the CRD matching level, the location overlapping rate and if necessary the text similarity rate. We evaluate our method on three software systems of different size and written in different languages. The results show that our method works well in clone group mapping under various circumstances, and it also can as a reliable foundation for constructing clone genealogies.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6840579
The Scent of a Smell: An Extensive Comparison Between Textual and Structural Smells,F. Palomba; A. Panichella; A. Zaidman; R. Oliveto; A. De Lucia,IEEE Transactions on Software Engineering,2018,"Code smells are symptoms of poor design or implementation choices that have a negative effect on several aspects of software maintenance and evolution, such as program comprehension or change- and fault-proneness. This is why researchers have spent a lot of effort on devising methods that help developers to automatically detect them in source code. Almost all the techniques presented in literature are based on the analysis of structural properties extracted from source code, although alternative sources of information (e.g., textual analysis) for code smell detection have also been recently investigated. Nevertheless, some studies have indicated that code smells detected by existing tools based on the analysis of structural properties are generally ignored (and thus not refactored) by the developers. In this paper, we aim at understanding whether code smells detected using textual analysis are perceived and refactored by developers in the same or different way than code smells detected through structural analysis. To this aim, we set up two different experiments. We have first carried out a software repository mining study to analyze how developers act on textually or structurally detected code smells. Subsequently, we have conducted a user study with industrial developers and quality experts in order to qualitatively analyze how they perceive code smells identified using the two different sources of information. Results indicate that textually detected code smells are easier to identify and for this reason they are considered easier to refactor with respect to code smells detected using structural properties. On the other hand, the latter are often perceived as more severe, but more difficult to exactly identify and remove.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8038053
APIEvolutionMiner: Keeping API evolution under control,A. Hora; A. Etien; N. Anquetil; S. Ducasse; M. T. Valente,"2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering (CSMR-WCRE)",2014,"During software evolution, source code is constantly refactored. In real-world migrations, many methods in the newer version are not present in the old version (e.g.,60% of the methods in Eclipse 2.0 were not in version 1.0). This requires changes to be consistently applied to reflect the new API and avoid further maintenance problems. In this paper, we propose a tool to extract rules by monitoring API changes applied in source code during system evolution. In this process, changes are mined at revision level in code history. Our tool focuses on mining invocation changes to keep track of how they are evolving. We also provide three case studies in order to evaluate the tool.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6747209
Cohesion-Driven Decomposition of Service Interfaces without Access to Source Code,D. Athanasopoulos; A. V. Zarras; G. Miskos; V. Issarny; P. Vassiliadis,IEEE Transactions on Services Computing,2015,"Software cohesion concerns the degree to which the elements of a module belong together. Cohesive software is easier to understand, test and maintain. In the context of service-oriented development, cohesion refers to the degree to which the operations of a service interface belong together. In the state of the art, software cohesion is improved based on refactoring methods that rely on information, extracted from the software implementation. This is a main limitation towards using these methods in the case of web services: web services do not expose their implementation; instead all that they export is the web service interface specification. To deal with this problem, we propose an approach that enables the cohesion-driven decomposition of service interfaces, without information on how the services are implemented. Our approach progressively decomposes a given service interface into more cohesive interfaces; the backbone of the approach is a suite of cohesion metrics that rely on information, extracted solely from the specification of the service interface. We validate the approach in 22 real-world services, provided by Amazon and Yahoo. We assess the effectiveness of the proposed approach, concerning the cohesion improvement, and the number of interfaces that result from the decomposition of the examined interfaces. Moreover, we show the usefulness of the approach in a user study, where developers assessed the quality of the produced interfaces.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6763104
Mining Association Rules to Facilitate Structural Recovery,W. Ren,2012 IEEE 36th Annual Computer Software and Applications Conference Workshops,2012,"In order to facilitate software maintenance, data mining techniques such as clustering and association rule mining can be used for extracting meaningful information from source code. Although in the past the techniques have been employed in independent or combinatorial ways for various maintenance activities, none of them combines dynamic information and visualization method to assist structural analysis. In this paper, we present a solution for enhancing the recovery process. First, execution traces are obtained using dynamic analysis and result matrices mapping between traces and method calls involved in the traces are generated. Based on the obtained matrices, clustering algorithm is applied to product an initial system structure, and association rule mining technique is also applied to build the associations among the clusters. Second, the obtained dynamic dependences based the analysis are demonstrated using visualization, in which software entities and associations are represented as nodes and edges, respectively. Thus the relations among clusters can be depicted, which are helpful for evaluating clustering quality and conducting potential refactoring. Through applying the approach on an actual application system, initial analysis is presented and the execution results can be used to guide further research work.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6341587
The Proposal of Model Transformation Support Method Based on Model Editing Operation History,N. Wada; Y. Noyori; H. Washizaki; Y. Fukazawa; H. Kanuka; H. Ohbayashi,2019 IEEE 8th Global Conference on Consumer Electronics (GCCE),2019,"Model Transformation is the tools of Model-driven development which realize the automation of model tasks (e.g. Refactoring, Modification). However, the tasks of model transformation require highly skills to create transformation rules. This makes it difficult for developers to work with models. In this paper, we propose a transformation support method to extract transformation rules based on the operation history of model editing by sequential pattern mining. Through the application of this proposal to simple case study, Model Division Pattern was generated as reusable pattern.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9015299
Codingâ„¢: Development Task Visualization for SW Code Comprehension,T. Kim; S. Kim; D. Ryu,2021 Working Conference on Software Visualization (VISSOFT),2021,"In a software development project, a developer tends to use the â€˜diffâ€™ view of the version control system (VCS) to understand development tasks such as fixing bugs, adding new features, and refactoring. However, the view only shows the difference of resources between the recent and previous versions in a commit, without providing any information about associated updates for completing a specific task. This causes a developer to spend a lot of time understanding development tasks, especially in the project where source code should be shared throughout team members. In order to handle this issue, we propose a novel tool Coding Time-Machine, in short Codingâ„¢, that automatically identifies and visualizes development tasks and their associated task elements (e.g., class and method). Codingâ„¢ extracts development tasks composed of task elements and causal relationships between them in a commit and facilitates one to compare the recent version of a code to the previous for each task. In addition, it allows one to navigate tasks of all commits in the code repository so that a developer feels like carrying out the time-travel of the coding activities in the software development project. For the evaluation, we measured the performance of tasks extracted from Codingâ„¢ for eight open-source Java projects, and obtained 0.87 of precision and 0.88 of recall. Also, we surveyed the usefulness of our tool for 20 participants, 80% of participants thought that showing tasks and their associated elements in a commit helps one to comprehend source code, and all participants responded that showing tasks in a chronicle way facilitates one to understand coding activities.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9604827
Exploring Paraphrasing Techniques on Formal Language for Generating Semantics Preserving Source Code Transformations,A. J. Stein; L. Kapllani; S. Mancoridis; R. Greenstadt,2020 IEEE 14th International Conference on Semantic Computing (ICSC),2020,"Automatically identifying and generating equivalent semantic content to a word, phrase, or sentence is an important part of natural language processing (NLP). The research done so far in paraphrases in NLP has been focused exclusively on textual data, but has significant potential if it is applied to formal languages like source code. In this paper, we present a novel technique for generating source code transformations via the use of paraphrases. We explore how to extract and validate source code paraphrases. The transformations can be used for stylometry tasks and processes like refactoring. A machine learning method of identifying valid transformations has the advantage of avoiding the generation of transformations by hand and is more likely to have more valid transformations. Our dataset is comprised by 27,300 C++ source code files, consisting of 273topics each with 10 parallel files. This generates approximately152,000 paraphrases. Of these paraphrases, 11% yield valid code transformations. We then train a random forest classifier that can identify valid transformations with 83% accuracy. In this paper we also discuss some of the observed relationships betweenlinked paraphrase transformations. We depict the relationshipsthat emerge between alternative equivalent code transformationsin a graph formalism.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9031503
Feature Envy Detection based on Bi-LSTM with Self-Attention Mechanism,H. Wang; J. Liu; J. Kang; W. Yin; H. Sun; H. Wang,"2020 IEEE Intl Conf on Parallel & Distributed Processing with Applications, Big Data & Cloud Computing, Sustainable Computing & Communications, Social Computing & Networking (ISPA/BDCloud/SocialCom/SustainCom)",2020,"Code Smell refers to suboptimal or harmful structures in the source code that may impede the maintainability of software. It serves as an effective way to detect refactoring opportunities. As the most prevailing smell, Feature Envy and its detection has been deeply explored for many years, which produces massive automated detection methods. Nevertheless, the heuristic-based approach cannot reach a satisfying level, and the machine learning approach still needs further optimization. Recent advances in deep learning inspire the birth of deep learning based approach. In this paper, we define a simpler distance metric as numerical feature and we collect class name and method name as text feature. Then we leverage Bidirectional Long-Short Term Memory (Bi-LSTM) Network with self-attention mechanism to extract semantic distance information in the text part, and we adopt embedding technology to enhance the structure distance information in the numerical part. Combined with the two sophisticatedly designed modules and the final classification module, a more reliable and accurate model is presented. Experimental results on seven open-source Java projects show that our model significantly outperforms existing methods.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9444004
Extracting Candidates of Microservices from Monolithic Application Code,M. Kamimura; K. Yano; T. Hatano; A. Matsuo,2018 25th Asia-Pacific Software Engineering Conference (APSEC),2018,"Technology that facilitates rapid modification of existing business applications is necessary and it has been reported that making the system more adaptable to change is the strongest driver for legacy system modernization. There has been considerable interest in service-oriented architectures or microservices which enables the system to be quickly changed. Refactoring and, in particular, re-modularization operations can be performed to repair the design of a software system. Various approaches have been proposed to support developers during the re-modularization of a software system. The common problem in these efforts is to identify from monolithic applications the candidates of microservices, i.e., the programs or data that can be turned into cohesive, standalone services; this is a tedious manual effort that requires analyzing many dimensions of software architecture views and often heavily relies on the experience and expertise of the expert performing the extraction. To solve this problem, we developed a method that identifies the candidates of microservices from the source code by using software clustering algorithm SArF with the relation of ""program groups"" and ""data"" which we defined. Our method also visualizes the extracted candidates to show the relationship between extracted candidates and the whole structure. The candidates and visualization help the developers to capture the overview of the whole system and facilitated a dialogue with customers. We report two case studies to evaluate our results in which we applied our method to an open source application and an industrial application with our results reviewed by developers.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8719439
Suggesting Extract Class Refactoring Opportunities by Measuring Strength of Method Interactions,G. Pappalardo; E. Tramontana,2013 20th Asia-Pacific Software Engineering Conference (APSEC),2013,"For improving the modularity of a large software system, metrics can be valuable to help finding refactoring opportunities for classes. We define a novel metric that is intended to suggest how closely connected are the elements of a class. The metric characterises the strength of the coupling between methods of a class, based on invocations and the size of the parameters involved, as well as attribute accesses. The assessment of the strength of interactions turns out to be valuable in providing an indication on the possible changes that classes need to become more modular and prone to be reused. According to the computed metric and the assessment of system-wide relationships between classes, we are able to suggest Extract Class refactoring opportunities. The capability of the proposed approach to evaluate object-oriented systems is demonstrated by analysing a large software system.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6754362
Common Agile Practices in Software Processes,J. F. Abrantes; G. H. Travassos,2011 International Symposium on Empirical Software Engineering and Measurement,2011,"Objective: to investigate studies about software processes looking for practices which can be used to obtain agility in software processes. Method: A systematic review including seven search engines was executed in Feb/2010. To apply the defined criteria to select papers and extract information regarding working practices bringing agility to software processes. Results: from 6696 retrieved papers, 441 were selected to support the identification of 236 occurrences of 51 distinct practices associated with the concept of agility. Their descriptions were deeply analyzed and consolidated. After discarding those which appeared in the technical literature in a small amount of papers, 17 agile practices were identified. Conclusion: although further studies are necessary to evaluate the efficacy of these 17 agile practices, 12 of them have been more commonly approached in the software projects and could be primarily considered: test driven development, continuous integration, pair programming, planning game, onsite customer, collective code ownership, small releases, metaphor, refactoring, sustainable pace, simple design and coding standards.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6092587
A Novel Tree-based Neural Network for Android Code Smells Detection,J. Yu; C. Mao; X. Ye,"2021 IEEE 21st International Conference on Software Quality, Reliability and Security (QRS)",2021,"The quality of mobile applications has received broad attention due to the booming development of mobile devices. Detection of Android code smells to refactor codes is an effective way to eliminate potential risks of applications. Besides traditional methods based on manually selected features, deep learning models provide an additional perspective of detection solutions. Though deep learning models are dispensed with artificial decisions, the paucity of dedicated datasets in Android code smells. The inadequate embedded syntax and semantics information acquired from source codes by token-based neural networks become new challenges. These obstacles will seriously affect the prediction performance of models. This paper put forward ACS-TNN, a novel Tree-based Neural Network approach for Android Code Smells detection. ACS-TNN took advantage of RvNN and LSTM while introducing ASTs for the first time in order to retain maximum semantic and structural information for extracting features of source codes. We constructed a dataset from practical open-source Android projects and labeled Java files data with popular Android code smells. The dataset would help researchers to train and test their deep learning models. Numerous experiments were conducted to investigate the prediction performance of ACS-TNN. The conclusions were that compared with two state-of-the-art token-based deep neural networks and another natural language tree-based model, ACS-TNN gained the best prediction performance. Further, ACS-TNN and our dataset are conducive to the maintenance of mobile applications.",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9724832