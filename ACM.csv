"Kanemitsu T,Higo Y,Kusumoto S",A Visualization Method of Program Dependency Graph for Identifying Extract Method Opportunity,2011,https://doi.org/10.1145/1984732.1984735;http://dx.doi.org/10.1145/1984732.1984735,"Refactoring is important for efficient software maintenance. However, tools supports are highly required for refactoring because manual operations of refactoring are troublesome and error prone. This paper proposes a technique that suggests Extract Method candidates automatically. Extract Method refactoring is to create a new method from a code fragment in an existing method. Previous research efforts showed that the Extract Method refactoring is often performed prior to other refactorings, so that it is important to support Extract Method refactoring. Previous studies have proposed methods that suggest Extract Method candidates based on linage or complexity. However it is originally desirable to divide methods based on their functionalities. This paper uses the strength of data connection between sentences in the source code. We deem that strongly-connected data expresses a single function. This paper proposes a technique that suggests Extract Method candidates based on strongly-connected data."
"Liu W,Liu H",Major Motivations for Extract Method Refactorings: Analysis Based on Interviews and Change Histories,2016,https://doi.org/10.1007/s11704-016-5131-4;http://dx.doi.org/10.1007/s11704-016-5131-4,"Extract method is one of the most popular software refactorings. However, little work has been done to investigate or validate the major motivations for such refactorings. Digging into this issue might help researchers to improve tool support for extract method refactorings, e.g., proposing better tools to recommend refactoring opportunities, and to select fragments to be extracted. To this end, we conducted an interview with 25 developers, and our results suggest that current reuse, decomposition of long methods, clone resolution, and future reuse are the major motivations for extract method refactorings.We also validated the results by analyzing the refactoring history of seven open-source applications. Analysis results suggest that current reuse was the primary motivation for 56% of extract method refactorings, decomposition of methods was the primary motivation for 28% of extract method refactorings, and clone resolution was the primary motivation for 16% of extract method refactorings. These findings might suggest that recommending extract method opportunities by analyzing only the inner structure (e.g., complexity and length) of methods alone would miss many extract method opportunities. These findings also suggest that extract method refactorings are often driven by current and immediate reuse. Consequently, how to recognize or predict reuse requirements timely during software evolution may play a key role in the recommendation and automation of extract method refactorings. We also investigated the likelihood for the extracted methods to be reused in future, and our results suggest that such methods have a small chance Received April 2, 2015; accepted November 10, 2015 E-mail: Liuhui08@bit.edu.cn (12%) to be reused in future unless the extracted fragment could be reused immediately in software evolution and extracting such a fragment can resolve existing clones at the same time."
Antezana AS,TOAD: A Tool for Recommending Auto-Refactoring Alternatives,2019,https://doi.org/10.1109/ICSE-Companion.2019.00071;http://dx.doi.org/10.1109/ICSE-Companion.2019.00071,"Developers often face usability problems when trying to adopt refactoring tools. We replicate a user study to identify and categorize these problems, and we propose a tool that guides the developer to select the correct piece of code for Extract Method refactoring. Our tool works during the workflow of refactoring activities and selects candidate selections that (i) are syntactically correct and (ii) meet the necessary preconditions for Extract Method."
"Silva D,Terra R,Valente MT",Recommending Automated Extract Method Refactorings,2014,https://doi.org/10.1145/2597008.2597141;http://dx.doi.org/10.1145/2597008.2597141,"Extract Method is a key refactoring for improving program comprehension. However, recent empirical research shows that refactoring tools designed to automate Extract Methods are often underused. To tackle this issue, we propose a novel approach to identify and rank Extract Method refactoring opportunities that are directly automated by IDE-based refactoring tools. Our approach aims to recommend new methods that hide structural dependencies that are rarely used by the remaining statements in the original method. We conducted an exploratory study to experiment and define the best strategies to compute the dependencies and the similarity measures used by the proposed approach. We also evaluated our approach in a sample of 81 extract method opportunities generated for JUnit and JHotDraw, achieving a precision of 48% (JUnit) and 38% (JHotDraw)."
"Tiwari O,Joshi R",Identifying Extract Method Refactorings,2022,https://doi.org/10.1145/3511430.3511435;http://dx.doi.org/10.1145/3511430.3511435,"Extract method refactoring identifies and extracts a set of statements implementing a specific functionality within a method. Its application enhances the structure of code and provides improved readability and reusability. This paper introduces Segmentation, a new approach for identifying extract method opportunities focusing on achieving higher performance with fewer suggestions. Evaluation of the approach includes six case studies from the open-source domain, and performance is compared against two state-of-the-art approaches. The findings suggest that Segmentation provides improved precision and F measure over both the approaches. Further, improved performance is reflected over long methods too."
"Hora A,Robbes R",Characteristics of Method Extractions in Java: A Large Scale Empirical Study,2020,https://doi.org/10.1007/s10664-020-09809-8;http://dx.doi.org/10.1007/s10664-020-09809-8,"Extract method is the â€œSwiss army knifeâ€ of refactorings: developers perform method extraction to introduce alternative signatures, decompose long code, improve testability, among many other reasons. Although the rationales behind method extraction are well explored, we are not yet aware of its characteristics. Assessing this information can provide the basis to better understand this important refactoring operation as well as improve refactoring tools and techniques based on the actual behavior of developers. In this paper, we assess characteristics of the extract method refactoring. We rely on a state-of-the-art technique to detect method extraction, and analyze over 70K instances of this refactoring, mined from 124 software systems. We investigate five aspects of this operation: magnitude, content, transformation, size, and degree. We find that (i) the extract method is among the most popular refactorings; (ii) extracted methods are over represented on operations related to creation, validation, and setup; (iii) methods that are targets of the extractions are 2.2x longer than the average, and they are reduced by one statement after the extraction; and (iv) single method extraction represents most, but not all, of the cases. We conclude by proposing improvements to refactoring detection, suggestion, and automation tools and techniques to support both practitioners and researchers."
"Gomes L,Cordeiro C,Alves EL",Evaluating the Effectiveness of Regression Test Suites for Extract Method Validation,2022,https://doi.org/10.1145/3559744.3559745;http://dx.doi.org/10.1145/3559744.3559745,"Refactoring edits aim to improve structural aspects of a system without changing its external behavior. However, while trying to perform a safe edit, a developer might introduce refactoring faults. To avoid refactoring faults, developers often use test suites to validate refactoring edits. However, depending on the quality of a test suite, its verdict may be misleading. In this work, we first present an empirical study that investigates the effectiveness of test suites (manually created and generated) for validating Extract Method refactoring faults. We found that manual suites detected 61,9% the injected faults, while generated suites detected only 46,7% (Randoop) and 55,8% (Evosuite). Then, we propose a new approach for evaluating the quality of a test suite for detecting refactoring faults. This approach is implemented by our prototype tool that focuses on two types of Extract Method faults. We demonstrate its applicability in a second empirical study that measured the quality of test suites from three different open-source projects."
"Pinto AF,Terra R",Better Similarity Coefficients to Identify Refactoring Opportunities,2017,https://doi.org/10.1145/3132498.3132511;http://dx.doi.org/10.1145/3132498.3132511,"Similarity coefficients are used by several techniques to identify refactoring opportunities. As an example, it is expected that a method is located in a class that is structurally similar to it. However, the existing coefficients in Literature have not been designed for the structural analysis of software systems, which may not guarantee satisfactory accuracy. This paper, therefore, proposes new coefficients---based on genetic algorithms over a training set of ten systems---to improve the accuracy of the identification of Move Class, Move Method, and Extract Method refactoring opportunities. We conducted an empirical study comparing these proposed coefficients with other 18 coefficients in other 101 systems. The results indicate, in relation to the best analyzed coefficient, an improvement of 10.57% for the identification of Move Method refactoring opportunities, 3.17% for Move Class, and 0.30% for Extract Method. Moreover, we implemented a tool that relies on the proposed coefficients to recommend refactoring opportunities."
"Corbat T,Felber L,Stocker M,Sommerlad P",Ruby Refactoring Plug-in for Eclipse,2007,https://doi.org/10.1145/1297846.1297884;http://dx.doi.org/10.1145/1297846.1297884,"This article presents our refactoring plug-in for the Eclipse Ruby Development Tools IDE.Refactoring is a very important technique for every software engineer to ensure the healthiness of his code and a cornerstone of agile software development.We have implemented sixteen automated refactorings and three code generators, for example Rename Variable and Extract Method."
"Tsantalis N,Chatzigeorgiou A",Identification of Extract Method Refactoring Opportunities,2009,https://doi.org/10.1109/CSMR.2009.23;http://dx.doi.org/10.1109/CSMR.2009.23,"Extract Method has been recognized as one of the most important refactorings, since it decomposes large methods and can be used in combination with other refactorings for fixing a variety of design problems. However, existing tools and methodologies support extraction of methods based on a set of statements selected by the user in the original method. The goal of the proposed methodology is to automatically identify Extract Method refactoring opportunities and present them as suggestions to the designer of an object-oriented system. The suggested refactorings adhere to three principles: the extracted code should contain the complete computation of a given variable declared in the original method, the behavior of the program should be preserved after the application of the refactoring, and the extracted code should not be excessively duplicated in the original method. The proposed approach is based on the union of static slices that result from the application of a block-based slicing technique. The soundness of the identified refactoring opportunities has been evaluated by an independent designer on the system that he developed."
"Maruyama K,Hayashi S",A Tool Supporting Postponable Refactoring,2017,https://doi.org/10.1109/ICSE-C.2017.108;http://dx.doi.org/10.1109/ICSE-C.2017.108,"Failures of precondition checking when attempting to apply automated refactorings often discourage programmers from attempting to use these refactorings in the future. To alleviate this situation, the postponement of the failed refactoring instead its cancellation is beneficial. This poster paper proposes a new concept of postponable refactoring and a prototype tool that implements postponable Extract Method as an Eclipse plug-in. We believe that this refactoring tool inspires a new field of reconciliation automated and manual refactoring."
"Alomar EA,Ivanov A,Kurbatova Z,Golubev Y,Mkaouer MW,Ouni A,Bryksin T,Nguyen L,Kini A,Thakur A",AntiCopyPaster: Extracting Code Duplicates As Soon As They Are Introduced in the IDE,2023,https://doi.org/10.1145/3551349.3559537;http://dx.doi.org/10.1145/3551349.3559537,"We developed a plugin for IntelliJ IDEA called AntiCopyPaster, which tracks the pasting of code fragments inside the IDE and suggests the appropriate Extract Method refactoring to combat the propagation of duplicates. Unlike the existing approaches, our tool is integrated with the developerâ€™s workflow, and pro-actively recommends refactorings. Since not all code fragments need to be extracted, we develop a classification model to make this decision. When a developer copies and pastes a code fragment, the plugin searches for duplicates in the currently opened file, waits for a short period of time to allow the developer to edit the code, and finally inferences the refactoring decision based on a number of features. Our experimental study on a large dataset of 18,942 code fragments mined from 13 Apache projects shows that AntiCopyPaster correctly recommends Extract Method refactorings with an F-score of 0.82. Furthermore, our survey of 59 developers reflects their satisfaction with the developed pluginâ€™s operation. The plugin and its source code are publicly available on GitHub at https://github.com/JetBrains-Research/anti-copy-paster. The demonstration video can be found on YouTube: https://youtu.be/_wwHg-qFjJY."
"Tsantalis N,Chatzigeorgiou A",Identification of Extract Method Refactoring Opportunities for the Decomposition of Methods,2011,https://doi.org/10.1016/j.jss.2011.05.016;http://dx.doi.org/10.1016/j.jss.2011.05.016,"The extraction of a code fragment into a separate method is one of the most widely performed refactoring activities, since it allows the decomposition of large and complex methods and can be used in combination with other code transformations for fixing a variety of design problems. Despite the significance of Extract Method refactoring towards code quality improvement, there is limited support for the identification of code fragments with distinct functionality that could be extracted into new methods. The goal of our approach is to automatically identify Extract Method refactoring opportunities which are related with the complete computation of a given variable (complete computation slice) and the statements affecting the state of a given object (object state slice). Moreover, a set of rules regarding the preservation of existing dependences is proposed that exclude refactoring opportunities corresponding to slices whose extraction could possibly cause a change in program behavior. The proposed approach has been evaluated regarding its ability to capture slices of code implementing a distinct functionality, its ability to resolve existing design flaws, its impact on the cohesion of the decomposed and extracted methods, and its ability to preserve program behavior. Moreover, precision and recall have been computed employing the refactoring opportunities found by independent evaluators in software that they developed as a golden set."
Perera R,Refactoring: To the Rubicon... and Beyond!,2004,https://doi.org/10.1145/1028664.1028666;http://dx.doi.org/10.1145/1028664.1028666,"We demonstrate a new approach to refactoring which involves the decomposition of familiar high-level refactorings such as Extract method into their components. By understanding all refactorings as the introduction or elimination of degrees of freedom we show how a large proportion of programming edits are in fact micro-refactorings, and gain an insight into how tools that support these micro-refactorings could have a dramatic impact on developer productivity."
Freese T,Inline Method Considered Helpful: An Approach to Interface Evolution,2003,,"While Extract Method is generally considered one of the most useful refactorings, the inverse refactoring Inline Method is so far only documented for removing methods whose bodies are as clear as their names. This paper outlines an approach how Inline Method may be used in changing method signatures and behavior. Furthermore, it proposes how the approach may simplify evolving published interfaces as well as merging parallel source code changes in next generation software configuration management tools."
"Laemmel R,Visser JM",Typed Combinators for Generic Traversal,2001,,"Lacking support for generic traversal, functional programming languages suffer from a scalability problem when applied to large-scale program transformation problems. As a solution, we introduce emphfunctional strategiess: typeful generic functions that not only can be applied to terms of any type, but which also allow generic traversal into subterms. We show how strategies are modelled inside a functional language, and we present a combinator library including generic traversal combinators. We illustrate our technique of programming with functional strategies by an implementation of the emphextract method refactoring for Java."
"LÃ¤mmel R,Visser J",Typed Combinators for Generic Traversal,2002,,"Lacking support for generic traversal, functional programming languages suffer from a scalability problem when applied to large-scale program transformation problems. As a solution, we introduce functional strategies: typeful generic functions that not only can be applied to terms of any type, but which also allow generic traversal into subterms. We show how strategies are modelled inside a functional language, and we present a combinator library including generic traversal combinators. We illustrate our technique of programming with functional strategies by an implementation of the extract method refactoring for Java."
Fernandes S,Towards a Live Environment for Code Refactoring,2023,https://doi.org/10.1145/3551349.3559569;http://dx.doi.org/10.1145/3551349.3559569,"Refactoring code manually can be complex. Several refactoring tools were developed to mitigate the effort needed to create more readable, adaptable, and maintainable code. However, most of them continue to provide late feedback, assistance, and support on how developers should improve their software. Thatâ€™s where the concept of Live Refactoring comes in. We believe the immediate and continuous suggestion of refactoring candidates to the code will help reduce this problem. Therefore, we prototyped a Live Refactoring Environment that identifies, recommends, and applies Extract Method refactorings. We carried out an empirical experiment that showed us that our approach helped developers reach better code, with more quality, improving their refactoring experience."
,WRT '12: Proceedings of the Fifth Workshop on Refactoring Tools,2012,,"Refactoring is the process of applying behavior-preserving transformations to a program with the objective of improving the program's design. A specific refactoring is identified by a name (e.g., Extract Method), a set of preconditions, and a set of specific transformations that need to be performed. Tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial program analysis, and applying the transformations may affect many locations throughout a program. In recent years, the emergence of light-weight programming methodologies such as Extreme Programming has generated a great amount of interest in refactoring, and refactoring support has become a required feature in modern-day IDEs."
"Smiari P,Bibi S,Ampatzoglou A,Arvanitou EM",Refactoring Embedded Software: A Study in Healthcare Domain,2022,https://doi.org/10.1016/j.infsof.2021.106760;http://dx.doi.org/10.1016/j.infsof.2021.106760,
"Shahidi M,Ashtiani M,Zakeri-Nasrabadi M",An Automated Extract Method Refactoring Approach to Correct the Long Method Code Smell,2022,https://doi.org/10.1016/j.jss.2022.111221;http://dx.doi.org/10.1016/j.jss.2022.111221,
"Fernandes S,Aguiar A,Restivo A",LiveRef: A Tool for Live Refactoring Java Code,2023,https://doi.org/10.1145/3551349.3559532;http://dx.doi.org/10.1145/3551349.3559532,"Refactoring software can be hard and time-consuming. Several refactoring tools assist developers in reaching more readable and maintainable code. However, most of them are characterized by long feedback loops that impoverish their refactoring experience. We believe that we can reduce this problem by focusing on the concept of Live Refactoring and its main principles: the live recommendation and continuous visualization of refactoring candidates, and the immediate visualization of results from applying a refactoring to the code. Therefore, we implemented a Live Refactoring Environment that identifies, suggests, and applies Extract Method refactorings. To evaluate our approach, we carried out an empirical experiment. Early results showed us that our refactoring environment improves several code quality aspects, being well received, understood, and used by the experiment participants. The source code of our tool is available on: https://github.com/saracouto1318/LiveRef. Its demonstration video can be found at: https://youtu.be/_jxx21ZiQ0o."
"AlOmar EA,Liu J,Addo K,Mkaouer MW,Newman C,Ouni A,Yu Z",On the Documentation of Refactoring Types,2022,https://doi.org/10.1007/s10515-021-00314-w;http://dx.doi.org/10.1007/s10515-021-00314-w,"Commit messages are the atomic level of software documentation. They provide a natural language description of the code change and its purpose. Messages are critical for software maintenance and program comprehension. Unlike documenting feature updates and bug fixes, little is known about how developers document their refactoring activities. Specifically, developers can perform multiple refactoring operations, including moving methods, extracting classes, renaming attributes, for various reasons, such as improving software quality, managing technical debt, and removing defects. Yet, there is no systematic study that analyzes the extent to which the documentation of refactoring accurately describes the refactoring operations performed at the source code level. Therefore, this paper challenges the ability of refactoring documentation, written in commit messages, to adequately predict the refactoring types, performed at the commit level. Our analysis relies on the text mining of commit messages to extract the corresponding features (i.e., keywords) that better represent each class (i.e., refactoring type). The extraction of text patterns, specific to each refactoring type (e.g., rename, extract, move, inline, etc.) allows the design of a model that verifies the consistency of these patterns with their corresponding refactoring. Such verification process can be achieved via automatically predicting, for a given commit, the method-level type of refactoring being applied, namely Extract Method, Inline Method, Move Method, Pull-up Method, Push-down Method, and Rename Method. We compared various classifiers, and a baseline keyword-based approach, in terms of their prediction performance, using a dataset of 5004 commits. Our main findings show that the complexity of refactoring type prediction varies from one type to another. Rename Method and Extract Method were found to be the best documented refactoring activities, while Pull-up Method, and Push-down Method were the hardest to be identified via textual descriptions. Such findings bring the attention of developers to the necessity of paying more attention to the documentation of these types."
"SchÃ¤fer M,Verbaere M,Ekman T,Moor O",Stepping Stones over the Refactoring Rubicon,2009,https://doi.org/10.1007/978-3-642-03013-0_17;http://dx.doi.org/10.1007/978-3-642-03013-0_17,"Refactoring tools allow the programmer to pretend they are working with a richer language where the behaviour of a program is automatically preserved during restructuring. In this paper we show that this metaphor of an extended language yields a very general and useful implementation technique for refactorings: a refactoring is implemented by embedding the source program into an extended language on which the refactoring operations are easier to perform, and then translating the refactored program back into the original language. Using the well-known Extract Method refactoring as an example, we show that this approach allows a very fine-grained decomposition of the overall refactoring into a series of micro-refactorings that can be understood, implemented, and tested independently. We thus can easily write implementations of complex refactorings that rival and even outperform industrial strength refactoring tools in terms of correctness, but are much shorter and easier to understand."
"Dig D,Batory D",Fourth Workshop on Refactoring Tools (WRT 2011),2011,https://doi.org/10.1145/1985793.1986046;http://dx.doi.org/10.1145/1985793.1986046,"Refactoring is the process of applying behavior-preserving transformations to a program with the objective of improving the program's design. A specific refactoring is identified by a name (e.g., Extract Method), a set of preconditions, and a set of transformations that need to be performed.Tool support for refactoring is essential because checking the preconditions of refactoring often requires nontrivial program analysis, and applying transformations may affect many locations throughout a program. In recent years, the emergence of light-weight programming methodologies such as Extreme Programming has generated a great amount of interest in refactoring, and refactoring support has become a required feature in today's IDEs.This workshop is a continuation of a series of previous workshops (ECOOP 2007, OOPSLA 2008 and 2009 - see http://refactoring.info/WRT) where researchers and developers of refactoring tools can meet and discuss recent ideas and work, and view tool demonstrations."
Volanschi N,Safe Clone-Based Refactoring through Stereotype Identification and Iso-Generation,2012,,"Most advanced existing tools for clone-based refactoring propose a limited number of pre-defined clone-removal transformations that can be applied automatically, typically under user control. This fixed set of refactorings usually guarantee that semantics is preserved, but is inherently limited to generally-applicable transformations (extract method, pull-up method, etc.). This tool design rules out many potential domain-specific or application-specific clone removals. Such cases are ordinarily recognized by humans as stereotypes derived from a higher-level concept and manually replaced with an appropriate abstraction. Thus, in current tools, generality is sacrificed for the safety of the transformation. This paper proposes an alternative approach, in which the spectrum of refactoring techniques is open, including manual interventions, while keeping strong safety guarantees based on the notion of iso-generation. Our method can operate on multiple languages and has been prototyped on a subset of a real-world legacy asset containing C and COBOL programs, with promising results."
"Yang L,Liu H,Niu Z",Identifying Fragments to Be Extracted from Long Methods,2009,https://doi.org/10.1109/APSEC.2009.20;http://dx.doi.org/10.1109/APSEC.2009.20,"Long and complex methods are hard to read or maintain, and thus usually treated as bad smells, known as Long Method. On the contrary, short and well-named methods are much easier to read, maintain, and extend. In order to divide long methods into short ones, refactoring Extract Method was proposed and has been widely used. However, extracting methods manually is time consuming and error prone. Though existing refactoring tools can automatically extract a selected fragment from its inclosing method, which fragment within a long method should be extracted has to be determined manually. In order to facilitate the decision-making, we propose an approach to recommend fragments within long methods for extraction. The approach is implemented as a prototype, called AutoMeD. With the tool, we evaluate the approach on a nontrivial open source project. The evaluation results suggest that refactoring cost of long methods can be reduced by nearly 40%. The main contribution of this paper is an approach to recommending fragments within long methods to be extracted, as well as an initial evaluation of the approach."
"Dig D,Fuhrer RM,Johnson R",The 2nd Workshop on Refactoring Tools (WRT'08),2008,https://doi.org/10.1145/1449814.1449885;http://dx.doi.org/10.1145/1449814.1449885,"Refactoring is the process of applying behavior-preserving transformations to a program with the objective of improving the program's design. A specific refactoring is identified by a name (e.g., Extract Method), a set of preconditions, and a set of specific transformations that need to be performed. Tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial and non-local program analysis, and applying the transformations may affect many locations in the program. In recent years, the emergence of light-weight programming methodologies such as Extreme Programming has generated a great amount of interest in refactoring, and refactoring support has become a required feature in modern-day IDEs. Until now, there has not been a suitable forum for discussions among researchers and developers of such tools. This full-day event on refactoring tools fills that need, with a strongly practical focus. The workshop features both presentations given by developers and researchers in the field of refactoring, as well as demonstrations of practical refactoring tools."
"Fuhrer RM,Opdyke WF",The 3rd ACM Workshop on Refactoring Tools (WRT'09),2009,https://doi.org/10.1145/1639950.1639980;http://dx.doi.org/10.1145/1639950.1639980,"Refactoring is the process of applying behavior-preserving transformations to a program with the objective of improving the program's design. A specific refactoring is identified by a name (e.g., Extract Method), a set of preconditions, and a set of specific transformations that need to be performed.Tool support for refactoring is highly desirable because checking the preconditions for a given refactoring often requires nontrivial program analysis, and applying the transformations may affect many locations throughout a program. In recent years, the emergence of light-weight programming methodologies such as Extreme Programming has generated a great amount of interest in refactoring, and refactoring support has become a required feature in modern-day IDEs.Until recently, there has not been a suitable forum for discussions among researchers and developers of such tools. Our prior refactoring tools workshops (initially at ECOOP 2007, then at OOPSLA 2008) clearly met a need, and there was strong interest expressed in holding a follow-on workshop. This workshop features both presentations given by developers and researchers in the field of refactoring, as well as demonstrations of practical refactoring tools."
"Milea NA,Jiang L,Khoo SC",Scalable Detection of Missed Cross-Function Refactorings,2014,https://doi.org/10.1145/2610384.2610394;http://dx.doi.org/10.1145/2610384.2610394,"Refactoring is an important way to improve the design of existing code. Identifying refactoring opportunities (i.e., code fragments that can be refactored) in large code bases is a challenging task. In this paper, we propose a novel, automated and scalable technique for identifying cross-function refactoring opportunities that span more than one function (e.g., Extract Method and Inline Method). The key of our technique is the design of efficient vector inlining operations that emulate the effect of method inlining among code fragments, so that the problem of identifying cross-function refactoring can be reduced to the problem of finding similar vectors before and after inlining. We have implemented our technique in a prototype tool named ReDex which encodes Java programs to particular vectors. We have applied the tool to a large code base, 4.5 million lines of code, comprising of 200 bundle projects in the Eclipse ecosystem (e.g., Eclipse JDT, Eclipse PDE, Apache Commons, Hamcrest, etc.). Also, different from many other studies on detecting refactoring, ReDex only searches for code fragments that can be, but have not yet been, refactored in a way similar to some refactoring that happened in the code base. Our results show that ReDex can find 277 cross-function refactoring opportunities in 2 minutes, and 223 cases were labelled as true opportunities by users, and cover many categories of cross-function refactoring operations in classical refactoring books, such as Self Encapsulate Field, Decompose Conditional Expression, Hide Delegate, Preserve Whole Object, etc."
"Murgia A,Marchesi M,Concas G,Tonelli R,Counsell S",Parameter-Based Refactoring and the Relationship with Fan-in/Fan-out Coupling,2011,https://doi.org/10.1109/ICSTW.2011.26;http://dx.doi.org/10.1109/ICSTW.2011.26,"Refactoring is an activity which, in theory, should have minimal impact on the overall structure of a system. That said, certain refactorings change the coupling profile of a system and over time those cumulative changes in coupling can have serious implications for system maintenance effort. In this paper, we analyse effect of the fan-in and fan-out metrics from the perspective of two refactorings--namely 'Add parameter' to, and 'Remove Parameter' from, a method. We developed a bespoke pattern-matching tool to collect these two refactorings from multiple releases of the Tomcat open-source system using the Evolizer tool to extract method signature data and the JHawk metrics tool to collect the two coupling metrics. Results point to significant differences in the profiles of fan-in and fan-out between refactored and non-refactored classes. We describe how software company can take advantage from this knowledge by defining a priority list of classes which could require a refactoring. A strong over-arching theme emerged: developers seemed to focus on the refactoring of classes with relatively high fan-in and fan-out rather than classes with high values in any one. The study is the first that we know of to analyse the direct effect of a subset of Fowler's refactorings on fan-in and fan-out - relevant metrics of the overall structure of a system."
"Ouni A,Kessentini M,Sahraoui H,Inoue K,Deb K",Multi-Criteria Code Refactoring Using Search-Based Software Engineering: An Industrial Case Study,2016,https://doi.org/10.1145/2932631;http://dx.doi.org/10.1145/2932631,"One of the most widely used techniques to improve the quality of existing software systems is refactoringâ€”the process of improving the design of existing code by changing its internal structure without altering its external behavior. While it is important to suggest refactorings that improve the quality and structure of the system, many other criteria are also important to consider, such as reducing the number of code changes, preserving the semantics of the software design and not only its behavior, and maintaining consistency with the previously applied refactorings. In this article, we propose a multi-objective search-based approach for automating the recommendation of refactorings. The process aims at finding the optimal sequence of refactorings that (i) improves the quality by minimizing the number of design defects, (ii) minimizes code changes required to fix those defects, (iii) preserves design semantics, and (iv) maximizes the consistency with the previously code changes. We evaluated the efficiency of our approach using a benchmark of six open-source systems, 11 different types of refactorings (move method, move field, pull up method, pull up field, push down method, push down field, inline class, move class, extract class, extract method, and extract interface) and six commonly occurring design defect types (blob, spaghetti code, functional decomposition, data class, shotgun surgery, and feature envy) through an empirical study conducted with experts. In addition, we performed an industrial validation of our technique, with 10 software engineers, on a large project provided by our industrial partner. We found that the proposed refactorings succeed in preserving the design coherence of the code, with an acceptable level of code change score while reusing knowledge from recorded refactorings applied in the past to similar contexts."
,WRT '11: Proceedings of the 4th Workshop on Refactoring Tools,2011,,"This volume contains the proceedings of the Fourth Workshop on Refactoring Tools (WRT 2011), held in conjunction with the International Conference on Software Engineering (ICSE 2011). This workshop is a continuation of a series of previous workshops (ECOOP 2007, OOPSLA 2008 and 2009, http://refactoring.info/WRT) where researchers and developers of refactoring tools can meet and discuss recent ideas and work, and view tool demonstrations.Refactoring is the process of applying behavior-preserving transformations to a program with the objective of improving the program's design. A specific refactoring is identified by a name (e.g., Extract Method), a set of preconditions, and a set of transformations that need to be performed.Tool support for refactoring is essential because checking the preconditions of refactoring often requires nontrivial program analysis, and applying transformations may affect many locations throughout a program. In recent years, the emergence of lightweight programming methodologies such as Extreme Programming has generated a great amount of interest in refactoring, and refactoring support has become a required feature in today's IDEs.While there is a great deal of interest in developing tool support for refactoring, researchers and tool vendors rarely work together. This forum fosters the transfer of ideas and expertise both ways: researchers can show the state-of-the-art analyses they are using in developing tool support for refactoring, tool vendors can offer valuable insights onthe challenges of scaling such analyses to realistic applications.By bringing together researchers and tool vendors, we can shorten the time to transfer ideas into production systems. In addition, by making researchers aware of what others are working on, the potential for reinventing the wheel is reduced and the potential for creative collaboration is enhanced.This year, we received 15 submissions of which 8 were accepted. We would like to thank the authors for submitting their work. We are extremely grateful to the Program Committee members who did an outstanding job at reviewing the submissions and providing constructive feedback on how the authors can further improve their work. We feel that the quality of the reviews rivals that of the larger conferences. We thank Bill Griswold, Sebastian Elbaum, and Kathryn Stolee for their keynotes. Also, we thank the ICSE workshop chairs, Matthew Dwyer and Wolgang Emmerich, for their dedication to a great workshop experience at ICSE."
"Fuhrer R,Tip F,Kie|un A",Advanced Refactorings in Eclipse,2004,https://doi.org/10.1145/1028664.1028669;http://dx.doi.org/10.1145/1028664.1028669,"We will demonstrate several advanced refactorings for Java that have been implemented in the context of the Eclipse development environment for Java (see www.eclipse.org). These refactorings are semantics-preserving program transformations that are typical of the sorts of transformations object-oriented programmers perform manually in order to improve the structure of existing code, and to promote reuse, clarity, and extensibility.Our demonstration will consist of three parts: (i) a quick review of the implementation in Eclipse of several widely-used refactorings such as Extract Method, Introduce Factory and Change Method Signature as described in Fowler's seminal book on refactoring, (ii) a demonstration of generalization-related refactorings such as Extract Interface, for extracting an interface from a class in order to reduce client dependencies on implementation particulars, and Generalize Type, for remediating over-specific declarations, and (iii) a demonstration of Genericize Container Uses, a refactoring that we are currently developing for migrating occurrences of standard container classes such as ArrayList or HashMap in a user's program to instantiations of the generic versions of these container classes in Java 1.5 (e.g., ArrayList). This involves determining the element types that flow into each container object, modifying their declarations and allocations sites where possible, and removing casts that have been rendered redundant.The latter two categories of refactorings involve non-trivial static analysis, as well as challenging usability issues from a software engineering perspective, which reflect the complications that programmers face when performing the transformations manually. Therefore, during each demonstration, we will give a brief overview of the technical challenges that the refactorings present, along with highlights of the approach we took in addressing them. In particular, we will briefly describe a new piece of Eclipse infrastructure designed to help implement various kinds of context-sensitive and context-insensitive type and pointer analyses for Java."
"Tavares CS,Ferreira F,Figueiredo E",A Systematic Mapping of Literature on Software Refactoring Tools,2018,https://doi.org/10.1145/3229345.3229357;http://dx.doi.org/10.1145/3229345.3229357,"Refactoring consists of improving the internal structure of the code without changing the external behavior of a software system. However, the task of refactoring is very costly in the development of an information system. Thus, many tools have been proposed to support refactoring the source code. In order to find tools cited in the literature, this work presents a Systematic Literature Mapping about refactoring. As a result, this paper summarizes the refactoring tools that have been published in the last 5 years in terms of the tool profiles developed, which programming languages have support for refactoring and which are the main refactoring strategies that are handled by tools. It has been identified that publications on refactoring have remained constant over the past 5 years. Also, most of the refactoring works describe tools, being they for systems written in the Java language, that perform code refactoring automatically and the main refactorings are: Move Method, Pull Up Method, Extract Class and Code Clone. Finally, we performed an analysis of the data returned by the DBLP library. As a result, it was observed that the papers returned by the DBLP have a high level of similarity with the other research bases studied."